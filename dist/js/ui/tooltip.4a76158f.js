const config = {debug: false,defaults: {placement: 'top', // 'top', 'bottom', 'left', 'right', 'auto'trigger: 'hover', // 'hover', 'focus', 'click', 'manual'showDelay: 200, // mshideDelay: 100, // msoffset: 8, // px from trigger elementarrow: true,html: false, // Allow HTML contentcontainer: 'body', // Where to append tooltipboundary: 'viewport', // Stay within boundary},classes: {tooltip: 'tooltip',arrow: 'tooltip-arrow',content: 'tooltip-content',show: 'tooltip-show',hide: 'tooltip-hide',},};const state = {tooltips: new Map(), // element -> tooltip instanceshowTimers: new Map(),hideTimers: new Map(),activeTooltip: null,initialized: false,};function log(...args) {if (config.debug) {console.log('[Tooltip]', ...args);}}function generateId() {return `tooltip-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;}function getElementRect(element) {return element.getBoundingClientRect();}function getViewport() {return {width: window.innerWidth || document.documentElement.clientWidth,height: window.innerHeight || document.documentElement.clientHeight,};}function calculatePosition(triggerRect, tooltipRect, placement, offset) {const viewport = getViewport();const positions = {top: {x: triggerRect.left + (triggerRect.width - tooltipRect.width) / 2,y: triggerRect.top - tooltipRect.height - offset,},bottom: {x: triggerRect.left + (triggerRect.width - tooltipRect.width) / 2,y: triggerRect.bottom + offset,},left: {x: triggerRect.left - tooltipRect.width - offset,y: triggerRect.top + (triggerRect.height - tooltipRect.height) / 2,},right: {x: triggerRect.right + offset,y: triggerRect.top + (triggerRect.height - tooltipRect.height) / 2,},};if (placement === 'auto') {const fits = {top: positions.top.y >= 0,bottom: positions.bottom.y + tooltipRect.height <= viewport.height,left: positions.left.x >= 0,right: positions.right.x + tooltipRect.width <= viewport.width,};if (fits.top) placement = 'top';else if (fits.bottom) placement = 'bottom';else if (fits.right) placement = 'right';else placement = 'left';}const pos = positions[placement];if (pos.x < 0) pos.x = 4;if (pos.x + tooltipRect.width > viewport.width) {pos.x = viewport.width - tooltipRect.width - 4;}if (pos.y < 0) pos.y = 4;if (pos.y + tooltipRect.height > viewport.height) {pos.y = viewport.height - tooltipRect.height - 4;}return { x: pos.x, y: pos.y, placement };}class Tooltip {constructor(element, options = {}) {if (!element) {throw new Error('Tooltip requires an element');}this.id = generateId();this.element = element;this.options = { ...config.defaults, ...options };this.tooltip = null;this.isVisible = false;this.listeners = new Map();this.content = this.options.content || element.getAttribute('title') ||element.getAttribute('data-tooltip');if (!this.content) {throw new Error('Tooltip requires content');}if (element.hasAttribute('title')) {element.removeAttribute('title');}this._createTooltip();this._setupListeners();state.tooltips.set(element, this);log('Tooltip created', this.id);}_createTooltip() {this.tooltip = document.createElement('div');this.tooltip.className = config.classes.tooltip;this.tooltip.setAttribute('role', 'tooltip');this.tooltip.id = this.id;this.element.setAttribute('aria-describedby', this.id);const content = document.createElement('div');content.className = config.classes.content;if (this.options.html) {content.innerHTML = this.content;} else {content.textContent = this.content;}this.tooltip.appendChild(content);if (this.options.arrow) {const arrow = document.createElement('div');arrow.className = config.classes.arrow;this.tooltip.appendChild(arrow);}this.tooltip.style.position = 'absolute';this.tooltip.style.display = 'none';this.tooltip.style.zIndex = '9999';}_setupListeners() {const { trigger } = this.options;if (trigger === 'hover') {const showHandler = () => this._scheduleShow();const hideHandler = () => this._scheduleHide();this.element.addEventListener('mouseenter', showHandler);this.element.addEventListener('mouseleave', hideHandler);this.element.addEventListener('focus', showHandler);this.element.addEventListener('blur', hideHandler);this.listeners.set('mouseenter', showHandler);this.listeners.set('mouseleave', hideHandler);this.listeners.set('focus', showHandler);this.listeners.set('blur', hideHandler);} else if (trigger === 'focus') {const showHandler = () => this._scheduleShow();const hideHandler = () => this._scheduleHide();this.element.addEventListener('focus', showHandler);this.element.addEventListener('blur', hideHandler);this.listeners.set('focus', showHandler);this.listeners.set('blur', hideHandler);} else if (trigger === 'click') {const toggleHandler = (e) => {e.preventDefault();this.toggle();};this.element.addEventListener('click', toggleHandler);this.listeners.set('click', toggleHandler);}if ('ontouchstart' in window) {const touchHandler = (_e) => {if (this.isVisible) {this.hide();} else {this.show();}};this.element.addEventListener('touchstart', touchHandler);this.listeners.set('touchstart', touchHandler);}}_removeListeners() {this.listeners.forEach((handler, event) => {this.element.removeEventListener(event, handler);});this.listeners.clear();}_scheduleShow() {const hideTimer = state.hideTimers.get(this);if (hideTimer) {clearTimeout(hideTimer);state.hideTimers.delete(this);}const showTimer = setTimeout(() => {this.show();state.showTimers.delete(this);}, this.options.showDelay);state.showTimers.set(this, showTimer);}_scheduleHide() {const showTimer = state.showTimers.get(this);if (showTimer) {clearTimeout(showTimer);state.showTimers.delete(this);}const hideTimer = setTimeout(() => {this.hide();state.hideTimers.delete(this);}, this.options.hideDelay);state.hideTimers.set(this, hideTimer);}_position() {if (!this.tooltip || !this.isVisible) return;const triggerRect = getElementRect(this.element);const tooltipRect = getElementRect(this.tooltip);const { x, y, placement } = calculatePosition(triggerRect,tooltipRect,this.options.placement,this.options.offset);this.tooltip.style.left = `${x}px`;this.tooltip.style.top = `${y}px`;this.tooltip.setAttribute('data-placement', placement);}show() {if (this.isVisible) return this;log('Showing tooltip', this.id);if (state.activeTooltip && state.activeTooltip !== this) {state.activeTooltip.hide();}const container = document.querySelector(this.options.container) || document.body;container.appendChild(this.tooltip);this.tooltip.style.display = 'block';requestAnimationFrame(() => {this._position();this.tooltip.classList.add(config.classes.show);});this.isVisible = true;state.activeTooltip = this;this._emit('show');return this;}hide() {if (!this.isVisible) return this;log('Hiding tooltip', this.id);this.tooltip.classList.remove(config.classes.show);this.tooltip.classList.add(config.classes.hide);setTimeout(() => {if (this.tooltip.parentNode) {this.tooltip.parentNode.removeChild(this.tooltip);}this.tooltip.classList.remove(config.classes.hide);this.tooltip.style.display = 'none';}, 200);this.isVisible = false;if (state.activeTooltip === this) {state.activeTooltip = null;}this._emit('hide');return this;}toggle() {return this.isVisible ? this.hide() : this.show();}setContent(content) {this.content = content;const contentEl = this.tooltip.querySelector(`.${config.classes.content}`);if (contentEl) {if (this.options.html) {contentEl.innerHTML = content;} else {contentEl.textContent = content;}}if (this.isVisible) {this._position();}return this;}setOptions(options) {Object.assign(this.options, options);return this;}_emit(eventName, detail = {}) {const event = new CustomEvent(`tooltip:${eventName}`, {detail: { tooltipId: this.id, element: this.element, ...detail },});window.dispatchEvent(event);}destroy() {if (this.isVisible) {this.hide();}const showTimer = state.showTimers.get(this);const hideTimer = state.hideTimers.get(this);if (showTimer) clearTimeout(showTimer);if (hideTimer) clearTimeout(hideTimer);this._removeListeners();if (this.tooltip && this.tooltip.parentNode) {this.tooltip.parentNode.removeChild(this.tooltip);}this.element.removeAttribute('aria-describedby');state.tooltips.delete(this.element);log('Tooltip destroyed', this.id);}}function init(element, options = {}) {if (!element) {throw new Error('Tooltip.init requires an element');}if (state.tooltips.has(element)) {return state.tooltips.get(element);}return new Tooltip(element, options);}function initAll(selector = '[data-tooltip], [title]', options = {}) {const elements = document.querySelectorAll(selector);const instances = [];elements.forEach(element => {if (!state.tooltips.has(element)) {try {instances.push(new Tooltip(element, options));} catch (error) {log('Failed to initialize tooltip', element, error);}}});return instances;}function getInstance(element) {return state.tooltips.get(element);}function destroy(element) {const tooltip = state.tooltips.get(element);if (tooltip) {tooltip.destroy();}}function destroyAll() {state.tooltips.forEach(tooltip => tooltip.destroy());}function hideAll() {state.tooltips.forEach(tooltip => tooltip.hide());}function configure(options) {Object.assign(config.defaults, options);log('Configuration updated', config.defaults);}function enableDebug() {config.debug = true;log('Debug mode enabled');}function disableDebug() {config.debug = false;}function getState() {return {initialized: state.initialized,totalTooltips: state.tooltips.size,activeTooltip: state.activeTooltip ? state.activeTooltip.id : null,};}if (typeof window !== 'undefined') {window.Tooltip = Tooltip;window.TooltipAPI = {Tooltip,init,initAll,getInstance,destroy,destroyAll,hideAll,configure,enableDebug,disableDebug,getState,};}