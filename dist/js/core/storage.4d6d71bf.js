const StorageType = {LOCAL: 'local',SESSION: 'session',MEMORY: 'memory', // Fallback when storage unavailable};const config = {debug: false,prefix: 'clodo_', // Namespace all keysdefaultTTL: null, // No expiry by default (ms)enableEvents: true,};const memoryStorage = new Map();function getNativeStorage(type) {switch (type) {case StorageType.LOCAL:return window.localStorage;case StorageType.SESSION:return window.sessionStorage;case StorageType.MEMORY:return null; // Use Mapdefault:throw new Error(`Invalid storage type: ${type}`);}}function isStorageAvailable(type) {try {const storage = getNativeStorage(type);if (!storage) return type === StorageType.MEMORY;const testKey = '__storage_test__';storage.setItem(testKey, 'test');storage.removeItem(testKey);return true;} catch {return false;}}function getPrefixedKey(key) {return `${config.prefix}${key}`;}function stripPrefix(key) {return key.startsWith(config.prefix) ? key.slice(config.prefix.length) : key;}function log(...args) {if (config.debug) {console.log('[Storage]', ...args);}}function emitEvent(eventName, detail) {if (!config.enableEvents) return;window.dispatchEvent(new CustomEvent(`storage:${eventName}`, {detail: {...detail,timestamp: Date.now(),},}));}function createStorageItem(value, ttl = null) {const expiryTime = ttl ? Date.now() + ttl : null;return {value,created: Date.now(),expires: expiryTime,version: 1,};}function isExpired(item) {if (!item.expires) return false;return Date.now() > item.expires;}class Storage {constructor(type = StorageType.LOCAL) {this.type = type;this.storage = getNativeStorage(type);this.available = isStorageAvailable(type);if (!this.available && type !== StorageType.MEMORY) {log(`${type} storage not available, falling back to memory storage`);this.type = StorageType.MEMORY;}log(`Initialized ${this.type} storage`);}set(key, value, ttl = null) {const prefixedKey = getPrefixedKey(key);const item = createStorageItem(value, ttl || config.defaultTTL);try {if (this.type === StorageType.MEMORY) {memoryStorage.set(prefixedKey, item);} else {this.storage.setItem(prefixedKey, JSON.stringify(item));}log(`Set "${key}"`, value, ttl ? `(TTL: ${ttl}ms)` : '');emitEvent('set', {key,value,ttl,storageType: this.type,});return true;} catch (error) {console.error(`[Storage] Failed to set "${key}":`, error);if (error.name === 'QuotaExceededError') {emitEvent('quota-exceeded', {key,error: error.message,storageType: this.type,});}return false;}}get(key, defaultValue = null) {const prefixedKey = getPrefixedKey(key);try {let item;if (this.type === StorageType.MEMORY) {item = memoryStorage.get(prefixedKey);} else {const raw = this.storage.getItem(prefixedKey);if (!raw) return defaultValue;item = JSON.parse(raw);}if (!item) return defaultValue;if (isExpired(item)) {log(`"${key}" expired, removing`);this.remove(key);emitEvent('expired', {key,storageType: this.type,});return defaultValue;}log(`Get "${key}"`, item.value);return item.value;} catch (error) {console.error(`[Storage] Failed to get "${key}":`, error);return defaultValue;}}has(key) {const prefixedKey = getPrefixedKey(key);try {if (this.type === StorageType.MEMORY) {const item = memoryStorage.get(prefixedKey);return item && !isExpired(item);}const raw = this.storage.getItem(prefixedKey);if (!raw) return false;const item = JSON.parse(raw);if (isExpired(item)) {this.remove(key);return false;}return true;} catch {return false;}}remove(key) {const prefixedKey = getPrefixedKey(key);try {if (this.type === StorageType.MEMORY) {memoryStorage.delete(prefixedKey);} else {this.storage.removeItem(prefixedKey);}log(`Remove "${key}"`);emitEvent('remove', {key,storageType: this.type,});return true;} catch (error) {console.error(`[Storage] Failed to remove "${key}":`, error);return false;}}clear() {try {if (this.type === StorageType.MEMORY) {const keys = Array.from(memoryStorage.keys()).filter(k =>k.startsWith(config.prefix));keys.forEach(k => memoryStorage.delete(k));log(`Cleared ${keys.length} items from memory storage`);return keys.length;}const keys = this.keys();keys.forEach(key => this.remove(key));log(`Cleared ${keys.length} items`);emitEvent('clear', {count: keys.length,storageType: this.type,});return keys.length;} catch (error) {console.error('[Storage] Failed to clear:', error);return 0;}}keys() {try {if (this.type === StorageType.MEMORY) {return Array.from(memoryStorage.keys()).filter(k => k.startsWith(config.prefix)).map(stripPrefix);}const keys = [];for (let i = 0; i < this.storage.length; i++) {const key = this.storage.key(i);if (key.startsWith(config.prefix)) {keys.push(stripPrefix(key));}}return keys;} catch (error) {console.error('[Storage] Failed to get keys:', error);return [];}}getAll() {const items = {};this.keys().forEach(key => {items[key] = this.get(key);});return items;}getSize() {try {if (this.type === StorageType.MEMORY) {let size = 0;memoryStorage.forEach((value, key) => {if (key.startsWith(config.prefix)) {size += JSON.stringify(value).length;}});return size;}let size = 0;this.keys().forEach(key => {const prefixedKey = getPrefixedKey(key);const value = this.storage.getItem(prefixedKey);size += prefixedKey.length + (value ? value.length : 0);});return size;} catch {return 0;}}async getRemainingQuota() {if (this.type === StorageType.MEMORY) {return Infinity;}try {if ('storage' in navigator && 'estimate' in navigator.storage) {const estimate = await navigator.storage.estimate();return estimate.quota - estimate.usage;}return null; // Unknown} catch {return null;}}cleanExpired() {let count = 0;this.keys().forEach(key => {const prefixedKey = getPrefixedKey(key);try {let item;if (this.type === StorageType.MEMORY) {item = memoryStorage.get(prefixedKey);} else {const raw = this.storage.getItem(prefixedKey);if (raw) item = JSON.parse(raw);}if (item && isExpired(item)) {this.remove(key);count++;}} catch {}});log(`Cleaned ${count} expired item(s)`);return count;}getTTL(key) {const prefixedKey = getPrefixedKey(key);try {let item;if (this.type === StorageType.MEMORY) {item = memoryStorage.get(prefixedKey);} else {const raw = this.storage.getItem(prefixedKey);if (raw) item = JSON.parse(raw);}if (!item || !item.expires) return null;const remaining = item.expires - Date.now();return remaining > 0 ? remaining : 0;} catch {return null;}}}function createStorage(type = StorageType.LOCAL, options = {}) {const instance = new Storage(type);if (options.prefix) {const originalPrefix = config.prefix;config.prefix = options.prefix;instance.prefix = options.prefix;return new Proxy(instance, {get(target, prop) {config.prefix = options.prefix;const value = target[prop];config.prefix = originalPrefix;return typeof value === 'function' ? value.bind(target) : value;},});}return instance;}let localStorage = null;let sessionStorage = null;function init(options = {}) {log('Initializing...');Object.assign(config, options);localStorage = new Storage(StorageType.LOCAL);sessionStorage = new Storage(StorageType.SESSION);setInterval(() => {localStorage.cleanExpired();sessionStorage.cleanExpired();}, 5 * 60 * 1000);log('Initialized ✓');}function destroy() {log('Destroying...');localStorage = null;sessionStorage = null;memoryStorage.clear();log('Destroyed ✓');}function configure(options) {Object.assign(config, options);log('Configuration updated', config);}function enableDebug() {config.debug = true;log('Debug mode enabled');}function disableDebug() {config.debug = false;}if (typeof window !== 'undefined') {window.StorageAPI = {init,destroy,configure,enableDebug,disableDebug,createStorage,StorageType,};window.StorageType = StorageType;}export {init,destroy,configure,enableDebug,disableDebug,createStorage,Storage,StorageType,};