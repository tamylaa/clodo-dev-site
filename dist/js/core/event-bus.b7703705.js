const config = {debug: false,maxHistory: 100, // Maximum events to keep in historyenableHistory: true,wildcardChar: '*',};const state = {listeners: new Map(), // event name -> array of handlershistory: [], // recent events for replayeventCount: 0,};class EventHandler {constructor(callback, options = {}) {this.id = `handler_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;this.callback = callback;this.priority = options.priority || 0;this.once = options.once || false;this.context = options.context || null;this.executed = false;}async execute(eventName, data) {if (this.once && this.executed) return;try {const result = this.context? await this.callback.call(this.context, data, eventName): await this.callback(data, eventName);this.executed = true;return result;} catch (error) {console.error(`[EventBus] Error in handler for "${eventName}":`, error);throw error;}}}function log(...args) {if (config.debug) {console.log('[EventBus]', ...args);}}function matchesPattern(eventName, pattern) {if (pattern === config.wildcardChar) return true;if (eventName === pattern) return true;const regexPattern = pattern.replace(/[.+?^${}()|[\]\\]/g, '\\$&') // Escape special chars.replace(/\*/g, '[^:]+'); // Replace * with patternconst regex = new RegExp(`^${regexPattern}$`);return regex.test(eventName);}function getHandlers(eventName) {const handlers = [];for (const [pattern, patternHandlers] of state.listeners) {if (matchesPattern(eventName, pattern)) {handlers.push(...patternHandlers);}}return handlers.sort((a, b) => b.priority - a.priority);}function on(eventName, callback, options = {}) {if (typeof callback !== 'function') {throw new TypeError('Callback must be a function');}const handler = new EventHandler(callback, options);if (!state.listeners.has(eventName)) {state.listeners.set(eventName, []);}state.listeners.get(eventName).push(handler);log(`Subscribed to "${eventName}" (priority: ${handler.priority})`);return () => off(eventName, handler.id);}function once(eventName, callback, options = {}) {return on(eventName, callback, { ...options, once: true });}function off(eventName, handlerOrId) {if (!state.listeners.has(eventName)) return false;const handlers = state.listeners.get(eventName);const id = typeof handlerOrId === 'string' ? handlerOrId : handlerOrId.id;const index = handlers.findIndex(h => h.id === id);if (index !== -1) {handlers.splice(index, 1);log(`Unsubscribed from "${eventName}"`);if (handlers.length === 0) {state.listeners.delete(eventName);}return true;}return false;}function offAll(eventName) {if (eventName) {const hadListeners = state.listeners.has(eventName);state.listeners.delete(eventName);log(`Removed all listeners for "${eventName}"`);return hadListeners;} else {const count = state.listeners.size;state.listeners.clear();log(`Removed all listeners (${count} events)`);return count > 0;}}async function emit(eventName, data = null) {state.eventCount++;log(`Emit "${eventName}"`, data);if (config.enableHistory) {state.history.push({name: eventName,data,timestamp: Date.now(),});if (state.history.length > config.maxHistory) {state.history.shift();}}const handlers = getHandlers(eventName);if (handlers.length === 0) {log(`No handlers for "${eventName}"`);return 0;}log(`Executing ${handlers.length} handler(s) for "${eventName}"`);const results = [];for (const handler of handlers) {try {const result = await handler.execute(eventName, data);results.push(result);if (handler.once) {for (const [pattern, patternHandlers] of state.listeners) {const index = patternHandlers.findIndex(h => h.id === handler.id);if (index !== -1) {patternHandlers.splice(index, 1);if (patternHandlers.length === 0) {state.listeners.delete(pattern);}break;}}}} catch (error) {results.push({ error });}}return results.length;}function emitSync(eventName, data = null) {setTimeout(() => {emit(eventName, data).catch(error => {console.error(`[EventBus] Unhandled error in emitSync for "${eventName}":`, error);});}, 0);}function hasListeners(eventName) {const handlers = getHandlers(eventName);return handlers.length > 0;}function listenerCount(eventName) {const handlers = getHandlers(eventName);return handlers.length;}function getEventNames() {return Array.from(state.listeners.keys());}function getHistory(eventName = null, limit = null) {let history = state.history;if (eventName) {history = history.filter(event => matchesPattern(event.name, eventName));}if (limit && limit > 0) {history = history.slice(-limit);}return history;}function clearHistory() {const count = state.history.length;state.history = [];log(`Cleared history (${count} events)`);return count;}async function replay(eventName = null, limit = null) {const events = getHistory(eventName, limit);log(`Replaying ${events.length} event(s)`);for (const event of events) {await emit(event.name, event.data);}return events.length;}function getStats() {return {totalEvents: state.eventCount,activeListeners: state.listeners.size,historySize: state.history.length,eventNames: getEventNames(),};}function reset() {state.listeners.clear();state.history = [];state.eventCount = 0;log('Event bus reset');}function enableDebug() {config.debug = true;log('Debug mode enabled');}function disableDebug() {config.debug = false;}function configure(options) {Object.assign(config, options);log('Configuration updated', config);}function init(options = {}) {log('Initializing...');configure(options);log('Initialized ✓');}function destroy() {log('Destroying...');reset();log('Destroyed ✓');}if (typeof window !== 'undefined') {window.EventBus = {init,destroy,on,once,off,offAll,emit,emitSync,hasListeners,listenerCount,getEventNames,getHistory,clearHistory,replay,getStats,reset,enableDebug,disableDebug,configure,};}export {init,destroy,on,once,off,offAll,emit,emitSync,hasListeners,listenerCount,getEventNames,getHistory,clearHistory,replay,getStats,reset,enableDebug,disableDebug,configure,};