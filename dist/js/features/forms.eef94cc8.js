const validators = {required: (value) => {const trimmed = String(value || '').trim();return {valid: trimmed.length > 0,message: 'This field is required'};},email: (value) => {const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;const trimmed = String(value || '').trim();return {valid: emailRegex.test(trimmed),message: 'Please enter a valid email address'};},url: (value) => {try {new URL(value);return { valid: true, message: '' };} catch {return {valid: false,message: 'Please enter a valid URL (e.g., https://example.com)'};}},minLength: (value, min) => {const length = String(value || '').length;return {valid: length >= min,message: `Must be at least ${min} characters`};},maxLength: (value, max) => {const length = String(value || '').length;return {valid: length <= max,message: `Must be no more than ${max} characters`};},pattern: (value, regex, message = 'Invalid format') => {const pattern = regex instanceof RegExp ? regex : new RegExp(regex);return {valid: pattern.test(String(value || '')),message};},phone: (value) => {const phoneRegex = /^[\d\s\-+()]{10,}$/;const trimmed = String(value || '').trim();return {valid: phoneRegex.test(trimmed),message: 'Please enter a valid phone number'};},numeric: (value) => {return {valid: !isNaN(parseFloat(value)) && isFinite(value),message: 'Please enter a valid number'};},min: (value, minValue) => {const num = parseFloat(value);return {valid: !isNaN(num) && num >= minValue,message: `Must be at least ${minValue}`};},max: (value, maxValue) => {const num = parseFloat(value);return {valid: !isNaN(num) && num <= maxValue,message: `Must be no more than ${maxValue}`};}};class FormState {constructor(form) {this.form = form;this.pristine = true;this.dirty = false;this.submitting = false;this.submitted = false;this.valid = false;this.errors = new Map();}markDirty() {this.pristine = false;this.dirty = true;}markSubmitting() {this.submitting = true;}markSubmitted() {this.submitting = false;this.submitted = true;}reset() {this.pristine = true;this.dirty = false;this.submitting = false;this.submitted = false;this.errors.clear();}setError(fieldName, message) {this.errors.set(fieldName, message);this.valid = false;}clearError(fieldName) {this.errors.delete(fieldName);this.valid = this.errors.size === 0;}clearAllErrors() {this.errors.clear();this.valid = true;}}function validateField(field, customRules = {}) {const value = field.value;const fieldName = field.name || field.id;const results = [];if (field.hasAttribute('required') || customRules.required) {results.push(validators.required(value));}if (field.type === 'email') {if (value) results.push(validators.email(value));} else if (field.type === 'url') {if (value) results.push(validators.url(value));} else if (field.type === 'tel') {if (value) results.push(validators.phone(value));} else if (field.type === 'number') {if (value) results.push(validators.numeric(value));}if (field.minLength && field.minLength > 0) {results.push(validators.minLength(value, field.minLength));}if (field.maxLength && field.maxLength > 0) {results.push(validators.maxLength(value, field.maxLength));}if (field.min !== '' && field.type === 'number') {results.push(validators.min(value, parseFloat(field.min)));}if (field.max !== '' && field.type === 'number') {results.push(validators.max(value, parseFloat(field.max)));}if (field.pattern) {results.push(validators.pattern(value, field.pattern, 'Invalid format'));}Object.entries(customRules).forEach(([ruleName, ruleValue]) => {if (validators[ruleName] && ruleName !== 'required') {if (typeof ruleValue === 'boolean' && ruleValue) {results.push(validators[ruleName](value));} else {results.push(validators[ruleName](value, ruleValue));}}});const firstError = results.find(r => !r.valid);return {valid: !firstError,message: firstError ? firstError.message : '',fieldName};}function showFieldError(field, message) {clearFieldError(field);field.setAttribute('aria-invalid', 'true');field.classList.add('field-error');const errorId = `${field.id || field.name}-error`;const errorEl = document.createElement('div');errorEl.id = errorId;errorEl.className = 'field-error-message';errorEl.textContent = message;errorEl.setAttribute('role', 'alert');errorEl.setAttribute('aria-live', 'polite');const formGroup = field.closest('.form-group') || field.parentElement;if (formGroup) {formGroup.appendChild(errorEl);} else {field.insertAdjacentElement('afterend', errorEl);}field.setAttribute('aria-describedby', errorId);}function clearFieldError(field) {field.setAttribute('aria-invalid', 'false');field.classList.remove('field-error');const errorId = `${field.id || field.name}-error`;const existingError = document.getElementById(errorId);if (existingError) {existingError.remove();}const describedBy = field.getAttribute('aria-describedby');if (describedBy === errorId) {field.removeAttribute('aria-describedby');}}function validateForm(form, customRules = {}) {const fields = form.querySelectorAll('input, textarea, select');const errors = [];fields.forEach(field => {if (field.type === 'hidden' || field.type === 'submit' || field.type === 'button') {return;}if (field.name === 'website' || field.classList.contains('hp-field')) {return;}const fieldRules = customRules[field.name] || {};const result = validateField(field, fieldRules);if (!result.valid) {errors.push(result);showFieldError(field, result.message);} else {clearFieldError(field);}});return {valid: errors.length === 0,errors,firstError: errors[0] || null};}function serializeForm(form) {const data = {};const fields = form.querySelectorAll('input, textarea, select');fields.forEach(field => {if (field.name === 'website' || field.classList.contains('hp-field')) {return;}if (field.disabled || field.type === 'submit' || field.type === 'button') {return;}const name = field.name;const value = field.value;if (data[name]) {if (Array.isArray(data[name])) {data[name].push(value);} else {data[name] = [data[name], value];}} else {data[name] = value;}});return data;}function setFormLoading(form, isLoading) {const submitBtn = form.querySelector('button[type="submit"]');const fields = form.querySelectorAll('input, textarea, select, button');if (isLoading) {fields.forEach(field => field.disabled = true);if (submitBtn) {submitBtn.setAttribute('aria-busy', 'true');submitBtn.classList.add('btn--loading');const spinner = submitBtn.querySelector('.btn-spinner, .spinner');if (spinner) {spinner.style.display = 'inline-block';}}form.classList.add('form--submitting');} else {fields.forEach(field => field.disabled = false);if (submitBtn) {submitBtn.setAttribute('aria-busy', 'false');submitBtn.classList.remove('btn--loading');const spinner = submitBtn.querySelector('.btn-spinner, .spinner');if (spinner) {spinner.style.display = 'none';}}form.classList.remove('form--submitting');}}function showFormMessage(form, message, type = 'success', duration = 5000) {let messageEl = form.querySelector('.form-message');if (!messageEl) {messageEl = document.createElement('div');messageEl.className = 'form-message';messageEl.setAttribute('role', type === 'error' ? 'alert' : 'status');messageEl.setAttribute('aria-live', 'polite');form.appendChild(messageEl);}messageEl.textContent = message;messageEl.className = `form-message form-message--${type}`;messageEl.style.display = 'block';if (duration > 0) {setTimeout(() => {messageEl.style.display = 'none';}, duration);}}function clearFormMessage(form) {const messageEl = form.querySelector('.form-message');if (messageEl) {messageEl.style.display = 'none';messageEl.textContent = '';}}async function handleFormSubmit(form, submitHandler, options = {}) {const {validate = true,customRules = {},successMessage = 'Success!',errorMessage = 'Something went wrong. Please try again.',resetOnSuccess = false,onSuccess = null,onError = null} = options;if (validate) {const validation = validateForm(form, customRules);if (!validation.valid) {if (validation.firstError) {const errorField = form.querySelector(`[name="${validation.firstError.fieldName}"]`);if (errorField) errorField.focus();}return;}}const formData = serializeForm(form);setFormLoading(form, true);clearFormMessage(form);try {const result = await submitHandler(formData);showFormMessage(form, successMessage, 'success');if (resetOnSuccess) {form.reset();}if (onSuccess) {onSuccess(result);}} catch (error) {const errMsg = error.message || errorMessage;showFormMessage(form, errMsg, 'error', 7000);if (onError) {onError(error);}console.error('[Forms] Submission error:', error);} finally {setFormLoading(form, false);}}function initRealtimeValidation(form, customRules = {}) {const fields = form.querySelectorAll('input, textarea, select');fields.forEach(field => {if (field.type === 'hidden' || field.type === 'submit' || field.type === 'button') {return;}if (field.name === 'website' || field.classList.contains('hp-field')) {return;}field.addEventListener('blur', () => {const fieldRules = customRules[field.name] || {};const result = validateField(field, fieldRules);if (!result.valid && field.value) {showFieldError(field, result.message);} else {clearFieldError(field);}});field.addEventListener('input', () => {clearFieldError(field);});});}if (typeof window !== 'undefined') {window.FormsAPI = {validateField,validateForm,showFieldError,clearFieldError,serializeForm,setFormLoading,showFormMessage,clearFormMessage,handleFormSubmit,initRealtimeValidation,validators,FormState};}export {validateField,validateForm,showFieldError,clearFieldError,serializeForm,setFormLoading,showFormMessage,clearFormMessage,handleFormSubmit,initRealtimeValidation,validators,FormState};