<!DOCTYPE html>
<html lang="en">
<head>
    <meta http-equiv="X-Frame-Options" content="DENY">
    <meta http-equiv="X-Content-Type-Options" content="nosniff">
    <meta http-equiv="Referrer-Policy" content="strict-origin-when-cross-origin">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'nonce-N0Nc3Cl0d0'; style-src 'self' https://fonts.googleapis.com https://fonts.gstatic.com; font-src 'self' https://fonts.gstatic.com; img-src 'self' data: https:; connect-src 'self' https://api.github.com; object-src 'none'; base-uri 'self'; form-action 'self';">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Authentication on Cloudflare Workers: JWT, OAuth, & Session Management</title>
    <link rel="canonical" href="https://clodo.dev/cloudflare-workers-auth">
    
    <!-- Hreflang tags for international SEO -->
    <link rel="alternate" hreflang="en" href="https://clodo.dev/cloudflare-workers-auth">
    <link rel="alternate" hreflang="en-GB" href="https://clodo.dev/cloudflare-workers-auth">
    <link rel="alternate" hreflang="en-AU" href="https://clodo.dev/cloudflare-workers-auth">
    <link rel="alternate" hreflang="en-IN" href="https://clodo.dev/cloudflare-workers-auth">
    <link rel="alternate" hreflang="x-default" href="https://clodo.dev/cloudflare-workers-auth">
    
    <meta name="description" content="Complete guide to implementing authentication in Cloudflare Workers. Learn JWT, OAuth, Cloudflare Access, Turnstile, and session management with code examples.">
    <!-- Open Graph -->
    <meta property="og:title" content="Authentication on Cloudflare Workers: Complete Guide">
    <meta property="og:description" content="Master authentication in Cloudflare Workers with JWT, OAuth, Access, and session management. Code examples and best practices included.">
    <meta property="og:image" content="https://clodo.dev/og-image.png">
    <meta property="og:url" content="https://clodo.dev/cloudflare-workers-auth">
    <!-- Twitter -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Authentication on Cloudflare Workers">
    <meta name="twitter:description" content="Complete authentication guide for Cloudflare Workers developers.">
    <meta name="twitter:image" content="https://clodo.dev/og-image.png">

    <!-- QAPage Schema for AI Search Optimization -->
    <script type="application/ld+json" nonce="N0Nc3Cl0d0">
    {
      "@context": "https://schema.org",
      "@type": "QAPage",
      "mainEntity": {
        "@type": "Question",
        "name": "How do I implement authentication in Cloudflare Workers?",
        "text": "Complete guide to authentication patterns in Cloudflare Workers including JWT, OAuth, Cloudflare Access, and session management.",
        "answerCount": 5,
        "acceptedAnswer": {
          "@type": "Answer",
          "text": "Cloudflare Workers support multiple authentication methods: 1) JWT tokens for stateless auth, 2) OAuth flows with external providers, 3) Cloudflare Access for zero-trust security, 4) Turnstile for bot protection, 5) Session management with Durable Objects.",
          "author": {
            "@type": "Organization",
            "name": "Clodo"
          }
        },
        "suggestedAnswer": [
          {
            "@type": "Answer",
            "text": "JWT is recommended for API authentication due to its stateless nature and performance benefits in serverless environments.",
            "author": {
              "@type": "Organization",
              "name": "Clodo"
            }
          },
          {
            "@type": "Answer",
            "text": "Use Cloudflare Access for enterprise applications requiring zero-trust security and SSO integration.",
            "author": {
              "@type": "Organization",
              "name": "Clodo"
            }
          }
        ]
      }
    }
    </script>

    <!-- Article Schema -->
    <script type="application/ld+json" nonce="N0Nc3Cl0d0">
    {
      "@context": "https://schema.org",
      "@type": "Article",
      "headline": "Authentication on Cloudflare Workers: JWT, OAuth, & Session Management",
      "description": "Comprehensive guide to implementing secure authentication in Cloudflare Workers, covering JWT tokens, OAuth flows, Cloudflare Access, Turnstile, and session management with Durable Objects.",
      "image": "https://clodo.dev/og-image.png",
      "datePublished": "2025-12-25T00:00:00Z",
      "dateModified": "2025-12-25T00:00:00Z",
      "author": {
        "@type": "Organization",
        "name": "Clodo",
        "url": "https://www.clodo.dev"
      },
      "publisher": {
        "@type": "Organization",
        "name": "Clodo",
        "logo": {
          "@type": "ImageObject",
          "url": "https://clodo.dev/logo.png"
        }
      },
      "keywords": ["Cloudflare Workers authentication", "JWT", "OAuth", "Cloudflare Access", "Turnstile", "session management"]
    }
    </script>

    <!-- BreadcrumbList Schema -->
    <script type="application/ld+json" nonce="N0Nc3Cl0d0">
    {
      "@context": "https://schema.org",
      "@type": "BreadcrumbList",
      "itemListElement": [
        {
          "@type": "ListItem",
          "position": 1,
          "name": "Home",
          "item": "https://www.clodo.dev"
        },
        {
          "@type": "ListItem",
          "position": 2,
          "name": "Cloudflare Workers Authentication Guide",
          "item": "https://clodo.dev/cloudflare-workers-auth"
        }
      ]
    }
    </script>

    <link rel="stylesheet" href="/styles.css">
    <link rel="icon" href="/favicon.svg" type="image/svg+xml">
</head>
<body>
    <!-- Navigation -->
    <nav class="nav-main">
        <div class="nav-container">
            <a href="/" class="nav-logo">Clodo</a>
            <ul class="nav-links">
                <li><a href="/docs">Docs</a></li>
                <li><a href="/examples">Examples</a></li>
                <li><a href="/blog">Blog</a></li>
                <li><a href="/pricing">Pricing</a></li>
            </ul>
        </div>
    </nav>

    <!-- Hero Section -->
    <section class="hero">
        <div class="hero-container">
            <h1>Authentication on Cloudflare Workers</h1>
            <p class="hero-subtitle">Complete guide to implementing secure authentication with JWT, OAuth, Cloudflare Access, and session management in serverless environments.</p>
            <div class="hero-cta">
                <a href="#jwt-auth" class="btn btn-primary">JWT Implementation</a>
                <a href="#oauth" class="btn btn-secondary">OAuth Flows</a>
            </div>
        </div>
    </section>

    <!-- Main Content -->
    <main class="main-content">
        <div class="content-container">

            <!-- Table of Contents -->
            <aside class="toc">
                <h3>Table of Contents</h3>
                <ul>
                    <li><a href="#auth-overview">Authentication Overview</a></li>
                    <li><a href="#jwt-auth">JWT Authentication</a></li>
                    <li><a href="#oauth">OAuth Integration</a></li>
                    <li><a href="#access">Cloudflare Access</a></li>
                    <li><a href="#turnstile">Turnstile Bot Protection</a></li>
                    <li><a href="#sessions">Session Management</a></li>
                    <li><a href="#security">Security Best Practices</a></li>
                </ul>
            </aside>

            <article class="article-content">

                <section id="auth-overview">
                    <h2>Authentication Methods Overview</h2>

                    <table class="auth-comparison">
                        <thead>
                            <tr>
                                <th>Method</th>
                                <th>Use Case</th>
                                <th>Pros</th>
                                <th>Cons</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>JWT</td>
                                <td>API authentication, stateless apps</td>
                                <td>Fast, stateless, scalable</td>
                                <td>Token revocation challenges</td>
                            </tr>
                            <tr>
                                <td>OAuth</td>
                                <td>Social login, third-party access</td>
                                <td>Delegated authorization, secure</td>
                                <td>Complex setup, requires providers</td>
                            </tr>
                            <tr>
                                <td>Cloudflare Access</td>
                                <td>Zero-trust security, enterprise</td>
                                <td>Zero-trust, SSO integration</td>
                                <td>Cloudflare-specific</td>
                            </tr>
                            <tr>
                                <td>Basic Auth</td>
                                <td>Simple APIs, internal tools</td>
                                <td>Simple implementation</td>
                                <td>Credentials in every request</td>
                            </tr>
                        </tbody>
                    </table>
                </section>

                <section id="jwt-auth">
                    <h2>JWT Authentication</h2>

                    <p>JWT (JSON Web Tokens) are perfect for Workers due to their stateless nature and fast verification.</p>

                    <h3>JWT Implementation</h3>
                    <pre><code>import jwt from 'jsonwebtoken';

export default {
  async fetch(request, env) {
    // Verify JWT token
    const authHeader = request.headers.get('Authorization');
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return new Response('Unauthorized', { status: 401 });
    }

    const token = authHeader.substring(7); // Remove 'Bearer '

    try {
      const decoded = jwt.verify(token, env.JWT_SECRET);
      // Token is valid, proceed with request
      return new Response(`Hello ${decoded.userId}!`);
    } catch (error) {
      return new Response('Invalid token', { status: 401 });
    }
  }
}</code></pre>

                    <h3>Creating JWT Tokens</h3>
                    <pre><code>// Login endpoint that creates JWT
export async function handleLogin(request, env) {
  const { email, password } = await request.json();

  // Verify credentials (implement your own logic)
  const user = await verifyCredentials(email, password);
  if (!user) {
    return new Response('Invalid credentials', { status: 401 });
  }

  // Create JWT token
  const token = jwt.sign(
    {
      userId: user.id,
      email: user.email,
      exp: Math.floor(Date.now() / 1000) + (24 * 60 * 60) // 24 hours
    },
    env.JWT_SECRET
  );

  return new Response(JSON.stringify({ token }), {
    headers: { 'Content-Type': 'application/json' }
  });
}</code></pre>

                    <h3>JWT Middleware</h3>
                    <pre><code>// Reusable JWT authentication middleware
export async function authenticate(request, env) {
  const authHeader = request.headers.get('Authorization');

  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    throw new Error('Missing or invalid authorization header');
  }

  const token = authHeader.substring(7);

  try {
    const decoded = jwt.verify(token, env.JWT_SECRET);

    // Add user info to request
    request.user = decoded;
    return request;
  } catch (error) {
    throw new Error('Invalid or expired token');
  }
}

// Usage in routes
export default {
  async fetch(request, env) {
    try {
      const authenticatedRequest = await authenticate(request, env);

      // Handle authenticated request
      return new Response(`Welcome ${authenticatedRequest.user.email}!`);
    } catch (error) {
      return new Response(error.message, { status: 401 });
    }
  }
}</code></pre>
                </section>

                <section id="oauth">
                    <h2>OAuth Integration</h2>

                    <p>OAuth allows users to authenticate using third-party providers like Google, GitHub, or Auth0.</p>

                    <h3>OAuth Flow Implementation</h3>
                    <pre><code>// OAuth initiation
export async function handleOAuthStart(request, env) {
  const state = crypto.randomUUID(); // CSRF protection

  // Store state in Durable Object or KV for verification
  await env.OAUTH_STATE.put(state, 'pending', { expirationTtl: 300 }); // 5 min

  const authUrl = new URL('https://github.com/login/oauth/authorize');
  authUrl.searchParams.set('client_id', env.GITHUB_CLIENT_ID);
  authUrl.searchParams.set('redirect_uri', `${env.BASE_URL}/oauth/callback`);
  authUrl.searchParams.set('scope', 'user:email');
  authUrl.searchParams.set('state', state);

  return Response.redirect(authUrl.toString());
}

// OAuth callback
export async function handleOAuthCallback(request, env) {
  const url = new URL(request.url);
  const code = url.searchParams.get('code');
  const state = url.searchParams.get('state');

  // Verify state to prevent CSRF
  const storedState = await env.OAUTH_STATE.get(state);
  if (!storedState) {
    return new Response('Invalid state', { status: 400 });
  }

  // Exchange code for access token
  const tokenResponse = await fetch('https://github.com/login/oauth/access_token', {
    method: 'POST',
    headers: {
      'Accept': 'application/json',
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      client_id: env.GITHUB_CLIENT_ID,
      client_secret: env.GITHUB_CLIENT_SECRET,
      code: code,
      redirect_uri: `${env.BASE_URL}/oauth/callback`
    })
  });

  const tokenData = await tokenResponse.json();

  if (tokenData.error) {
    return new Response('OAuth failed', { status: 400 });
  }

  // Get user info
  const userResponse = await fetch('https://api.github.com/user', {
    headers: {
      'Authorization': `Bearer ${tokenData.access_token}`,
      'User-Agent': 'Clodo-App'
    }
  });

  const userData = await userResponse.json();

  // Create session or JWT for your app
  const sessionToken = jwt.sign({
    userId: userData.id,
    provider: 'github',
    exp: Math.floor(Date.now() / 1000) + (7 * 24 * 60 * 60) // 7 days
  }, env.JWT_SECRET);

  // Redirect to app with session token
  return Response.redirect(`${env.FRONTEND_URL}/login/success?token=${sessionToken}`);
}</code></pre>

                    <h3>OAuth with Auth0</h3>
                    <pre><code>// Auth0 integration
export async function handleAuth0Login(request, env) {
  const authUrl = new URL(`https://${env.AUTH0_DOMAIN}/authorize`);
  authUrl.searchParams.set('client_id', env.AUTH0_CLIENT_ID);
  authUrl.searchParams.set('redirect_uri', `${env.BASE_URL}/auth0/callback`);
  authUrl.searchParams.set('response_type', 'code');
  authUrl.searchParams.set('scope', 'openid profile email');
  authUrl.searchParams.set('state', crypto.randomUUID());

  return Response.redirect(authUrl.toString());
}

export async function handleAuth0Callback(request, env) {
  const url = new URL(request.url);
  const code = url.searchParams.get('code');

  // Exchange code for tokens
  const tokenResponse = await fetch(`https://${env.AUTH0_DOMAIN}/oauth/token`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      grant_type: 'authorization_code',
      client_id: env.AUTH0_CLIENT_ID,
      client_secret: env.AUTH0_CLIENT_SECRET,
      code: code,
      redirect_uri: `${env.BASE_URL}/auth0/callback`
    })
  });

  const tokens = await tokenResponse.json();

  // Decode ID token to get user info
  const userInfo = jwt.decode(tokens.id_token);

  return new Response(JSON.stringify({
    access_token: tokens.access_token,
    user: userInfo
  }));
}</code></pre>
                </section>

                <section id="access">
                    <h2>Cloudflare Access</h2>

                    <p>Cloudflare Access provides zero-trust security with SSO integration.</p>

                    <h3>Access JWT Validation</h3>
                    <pre><code>// Validate Cloudflare Access JWT
export async function validateAccessToken(request, env) {
  const token = request.headers.get('Cf-Access-Jwt-Assertion');

  if (!token) {
    return new Response('Access token missing', { status: 401 });
  }

  try {
    // Fetch Cloudflare's public keys
    const keysResponse = await fetch(`https://${env.CLOUDFLARE_TEAM}.cloudflareaccess.com/cdn-cgi/access/certs`);
    const keys = await keysResponse.json();

    // Verify JWT (simplified - use a proper JWT library)
    const decoded = jwt.verify(token, keys.keys[0].x, {
      issuer: `https://${env.CLOUDFLARE_TEAM}.cloudflareaccess.com`,
      audience: env.ACCESS_AUDIENCE
    });

    return decoded;
  } catch (error) {
    return new Response('Invalid access token', { status: 401 });
  }
}

// Protected route
export default {
  async fetch(request, env) {
    const user = await validateAccessToken(request, env);

    if (!user) {
      return new Response('Unauthorized', { status: 401 });
    }

    return new Response(`Hello ${user.email}!`);
  }
}</code></pre>

                    <h3>Access with Service Tokens</h3>
                    <pre><code>// Service token authentication for API-to-API
export async function validateServiceToken(request, env) {
  const token = request.headers.get('Authorization')?.replace('Bearer ', '');

  if (!token) {
    return false;
  }

  // Verify service token (implement your own validation)
  const expectedToken = await env.SERVICE_TOKENS.get('api-service');

  return token === expectedToken;
}

// API route with service token auth
export async function handleAPIRequest(request, env) {
  const isValidService = await validateServiceToken(request, env);

  if (!isValidService) {
    return new Response('Invalid service token', { status: 401 });
  }

  // Process API request
  return new Response('API response');
}</code></pre>
                </section>

                <section id="turnstile">
                    <h2>Turnstile Bot Protection</h2>

                    <p>Turnstile provides invisible bot protection and CAPTCHA challenges.</p>

                    <h3>Turnstile Integration</h3>
                    <pre><code>// Verify Turnstile token
export async function verifyTurnstile(token, env) {
  const response = await fetch('https://challenges.cloudflare.com/turnstile/v0/siteverify', {
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
    body: new URLSearchParams({
      secret: env.TURNSTILE_SECRET,
      response: token
    })
  });

  const result = await response.json();
  return result.success;
}

// Login with Turnstile verification
export async function handleLogin(request, env) {
  const { email, password, turnstileToken } = await request.json();

  // Verify Turnstile token first
  const isValidBot = await verifyTurnstile(turnstileToken, env);
  if (!isValidBot) {
    return new Response('Bot verification failed', { status: 400 });
  }

  // Proceed with authentication
  const user = await verifyCredentials(email, password);
  if (!user) {
    return new Response('Invalid credentials', { status: 401 });
  }

  const token = jwt.sign({ userId: user.id }, env.JWT_SECRET);
  return new Response(JSON.stringify({ token }));
}</code></pre>

                    <h3>Frontend Turnstile Integration</h3>
                    <pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;Login with Turnstile&lt;/title&gt;
  &lt;script src="https://challenges.cloudflare.com/turnstile/v0/api.js" async defer&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;form id="loginForm"&gt;
    &lt;input type="email" name="email" placeholder="Email" required&gt;
    &lt;input type="password" name="password" placeholder="Password" required&gt;

    &lt;!-- Turnstile widget --&gt;
    &lt;div class="cf-turnstile" data-sitekey="YOUR_SITE_KEY"&gt;&lt;/div&gt;

    &lt;button type="submit"&gt;Login&lt;/button&gt;
  &lt;/form&gt;

  &lt;script&gt;
    document.getElementById('loginForm').addEventListener('submit', async (e) => {
      e.preventDefault();

      const formData = new FormData(e.target);
      const turnstileToken = formData.get('cf-turnstile-response');

      const response = await fetch('/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          email: formData.get('email'),
          password: formData.get('password'),
          turnstileToken: turnstileToken
        })
      });

      const result = await response.json();
      if (response.ok) {
        localStorage.setItem('token', result.token);
        window.location.href = '/dashboard';
      } else {
        alert(result.error);
      }
    });
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
                </section>

                <section id="sessions">
                    <h2>Session Management with Durable Objects</h2>

                    <p>Use Durable Objects for server-side session storage in stateless Workers.</p>

                    <h3>Durable Object Session Store</h3>
                    <pre><code>// Session Durable Object
export class SessionStore {
  constructor(state) {
    this.state = state;
    this.sessions = new Map();
  }

  async handleSession(request) {
    const url = new URL(request.url);

    if (request.method === 'POST') {
      // Create session
      const sessionId = crypto.randomUUID();
      const sessionData = await request.json();

      this.sessions.set(sessionId, {
        ...sessionData,
        created: Date.now(),
        lastAccess: Date.now()
      });

      return new Response(JSON.stringify({ sessionId }));
    }

    if (request.method === 'GET') {
      // Get session
      const sessionId = url.searchParams.get('id');

      if (!this.sessions.has(sessionId)) {
        return new Response('Session not found', { status: 404 });
      }

      const session = this.sessions.get(sessionId);
      session.lastAccess = Date.now();

      return new Response(JSON.stringify(session));
    }

    if (request.method === 'DELETE') {
      // Delete session
      const sessionId = url.searchParams.get('id');
      this.sessions.delete(sessionId);

      return new Response('Session deleted');
    }

    return new Response('Method not allowed', { status: 405 });
  }
}

export default {
  async fetch(request, env) {
    const id = env.SESSION_STORE.idFromName('global-sessions');
    const stub = env.SESSION_STORE.get(id);

    return stub.fetch(request);
  }
}</code></pre>

                    <h3>Session Middleware</h3>
                    <pre><code>// Session middleware for Workers
export async function withSession(handler, env) {
  return async (request) => {
    const sessionId = getSessionIdFromRequest(request);

    if (sessionId) {
      // Get session data
      const sessionResponse = await env.SESSION_STORE.fetch(
        `${env.SESSION_STORE_URL}?id=${sessionId}`
      );

      if (sessionResponse.ok) {
        const sessionData = await sessionResponse.json();
        request.session = sessionData;
      }
    }

    const response = await handler(request, env);

    // Set session cookie if needed
    if (request.newSession) {
      const sessionCookie = `session=${request.newSession.id}; HttpOnly; Secure; SameSite=Strict`;
      response.headers.set('Set-Cookie', sessionCookie);
    }

    return response;
  };
}

function getSessionIdFromRequest(request) {
  const cookie = request.headers.get('Cookie');
  if (!cookie) return null;

  const sessionMatch = cookie.match(/session=([^;]+)/);
  return sessionMatch ? sessionMatch[1] : null;
}

// Usage
const authenticatedHandler = withSession(async (request, env) => {
  if (!request.session) {
    return new Response('Not authenticated', { status: 401 });
  }

  return new Response(`Hello ${request.session.user.email}!`);
}, env);</code></pre>
                </section>

                <section id="security">
                    <h2>Security Best Practices</h2>

                    <h3>Rate Limiting</h3>
                    <pre><code>// Rate limiting with Durable Objects
export class RateLimiter {
  constructor(state) {
    this.state = state;
    this.requests = new Map();
  }

  async checkLimit(identifier, maxRequests = 100, windowMs = 60000) {
    const now = Date.now();
    const windowStart = now - windowMs;

    if (!this.requests.has(identifier)) {
      this.requests.set(identifier, []);
    }

    const userRequests = this.requests.get(identifier);

    // Remove old requests outside the window
    const validRequests = userRequests.filter(time => time > windowStart);
    this.requests.set(identifier, validRequests);

    if (validRequests.length >= maxRequests) {
      return false; // Rate limit exceeded
    }

    validRequests.push(now);
    return true; // Within limit
  }
}

// Usage in Worker
export default {
  async fetch(request, env) {
    const clientIP = request.headers.get('CF-Connecting-IP');
    const limiterId = env.RATE_LIMITER.idFromName(clientIP);
    const limiter = env.RATE_LIMITER.get(limiterId);

    const withinLimit = await limiter.checkLimit(clientIP);

    if (!withinLimit) {
      return new Response('Rate limit exceeded', {
        status: 429,
        headers: { 'Retry-After': '60' }
      });
    }

    // Process request
    return new Response('OK');
  }
}</code></pre>

                    <h3>Input Validation and Sanitization</h3>
                    <pre><code>// Input validation utilities
export function validateEmail(email) {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
}

export function sanitizeInput(input) {
  if (typeof input !== 'string') return input;

  // Remove potentially dangerous characters
  return input.replace(/[<>'"&]/g, '');
}

export function validatePassword(password) {
  // At least 8 characters, one uppercase, one lowercase, one number
  const passwordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)[a-zA-Z\d@$!%*?&]{8,}$/;
  return passwordRegex.test(password);
}

// Usage in auth endpoint
export async function handleRegistration(request, env) {
  const { email, password, name } = await request.json();

  // Validate inputs
  if (!validateEmail(email)) {
    return new Response('Invalid email', { status: 400 });
  }

  if (!validatePassword(password)) {
    return new Response('Password too weak', { status: 400 });
  }

  const sanitizedName = sanitizeInput(name);

  // Proceed with registration
  const user = await createUser(env, email, password, sanitizedName);

  return new Response(JSON.stringify(user));
}</code></pre>

                    <h3>Secure Headers</h3>
                    <pre><code>// Security headers middleware
export function addSecurityHeaders(response) {
  const headers = new Headers(response.headers);

  // Prevent clickjacking
  headers.set('X-Frame-Options', 'DENY');

  // Prevent MIME type sniffing
  headers.set('X-Content-Type-Options', 'nosniff');

  // Enable XSS protection
  headers.set('X-XSS-Protection', '1; mode=block');

  // Strict transport security
  headers.set('Strict-Transport-Security', 'max-age=31536000; includeSubDomains');

  // Content Security Policy
  headers.set('Content-Security-Policy', "default-src 'self'; script-src 'self'");

  // Referrer policy
  headers.set('Referrer-Policy', 'strict-origin-when-cross-origin');

  return new Response(response.body, {
    status: response.status,
    statusText: response.statusText,
    headers
  });
}

// Apply to all responses
export default {
  async fetch(request, env) {
    const response = await handleRequest(request, env);
    return addSecurityHeaders(response);
  }
}</code></pre>
                </section>

                <!-- Related Questions for AEO -->
                <section id="related-questions">
                    <h2>Related Questions</h2>

                    <div class="related-questions">
                        <div class="question-item">
                            <h3>Can I use multiple authentication methods together?</h3>
                            <p>Yes, you can combine JWT for API auth with Cloudflare Access for admin routes, and Turnstile for bot protection on public forms.</p>
                        </div>

                        <div class="question-item">
                            <h3>How do I handle authentication in a multi-tenant app?</h3>
                            <p>Use tenant-specific JWT secrets, isolate sessions per tenant in Durable Objects, and implement tenant-scoped access controls.</p>
                        </div>

                        <div class="question-item">
                            <h3>What's the difference between JWT and sessions?</h3>
                            <p>JWT is stateless and stored client-side, while sessions require server-side storage but offer better control over token revocation.</p>
                        </div>

                        <div class="question-item">
                            <h3>How do I secure my authentication endpoints?</h3>
                            <p>Use HTTPS, implement rate limiting, validate all inputs, use secure headers, and consider Cloudflare Access for additional protection.</p>
                        </div>
                    </div>
                </section>

                <!-- Related Content -->
                <section class="related-content">
                    <h2>Related Resources</h2>
                    <div class="related-links">
                        <a href="/cloudflare-workers-guide" class="related-link">
                            <h3>Cloudflare Workers Guide</h3>
                            <p>Complete guide to building applications with Cloudflare Workers</p>
                        </a>
                        <a href="/docs" class="related-link">
                            <h3>Clodo Documentation</h3>
                            <p>Official documentation for the Clodo framework</p>
                        </a>
                        <a href="/examples" class="related-link">
                            <h3>Code Examples</h3>
                            <p>Authentication examples and code snippets</p>
                        </a>
                    </div>
                </section>

            </article>
        </div>
    </main>

    <!-- Footer -->
    <footer class="footer">
        <div class="footer-container">
            <div class="footer-section">
                <h4>Clodo Framework</h4>
                <p>Pre-Flight Checker for Cloudflare Workers</p>
                <p>Reduce custom software costs by 60%</p>
            </div>
            <div class="footer-section">
                <h4>Resources</h4>
                <ul>
                    <li><a href="/docs">Documentation</a></li>
                    <li><a href="/examples">Examples</a></li>
                    <li><a href="/blog">Blog</a></li>
                    <li><a href="/community">Community</a></li>
                </ul>
            </div>
            <div class="footer-section">
                <h4>Support</h4>
                <ul>
                    <li><a href="/faq">FAQ</a></li>
                    <li><a href="https://github.com/your-repo">GitHub</a></li>
                    <li><a href="/pricing#contact">Contact</a></li>
                </ul>
            </div>
        </div>
        <div class="footer-bottom">
            <p>&copy; 2025 Clodo. All rights reserved.</p>
        </div>
    </footer>

    <script src="/script.js" nonce="N0Nc3Cl0d0"></script>
</body>
</html>
