<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Debugging Production: When Git Submodules Fail Silently | Clodo Framework</title>
    <meta name="description" content="A technical deep-dive into debugging silent Cloudflare Pages build failures caused by broken git submodules, cache invalidation, and deployment strategies.">
    <meta name="keywords" content="git submodules, debugging, Cloudflare Pages, deployment, cache busting, production debugging">
    <link rel="canonical" href="https://clodo.dev/blog/debugging-silent-build-failures.html">
    <link rel="stylesheet" href="../styles.css">
    <link rel="icon" href="../icons/icon.svg" type="image/svg+xml">
</head>
<body>
    <!-- HEADER_PLACEHOLDER -->
    
    <main id="main-content" class="blog-post">
        <article class="container">
            <header class="blog-post__header">
                <div class="blog-post__meta">
                    <time datetime="2025-11-11">November 11, 2025</time>
                    <span class="blog-post__reading-time">10 min read</span>
                    <span class="blog-post__category">Technical Deep-Dive</span>
                </div>
                <h1>Debugging Production: When Git Submodules Fail Silently</h1>
                <p class="blog-post__subtitle">A forensic analysis of how a broken git submodule caused Cloudflare Pages builds to fail without error messages</p>
                <div class="blog-post__author">
                    <img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ccircle cx='50' cy='50' r='50' fill='%234F46E5'/%3E%3Ctext x='50' y='60' font-size='40' font-weight='bold' text-anchor='middle' fill='white'%3ET%3C/text%3E%3C/svg%3E" alt="Photo of Tamyla, Founder of Clodo Framework" class="blog-post__avatar" loading="lazy" decoding="async">
                    <div>
                        <div class="blog-post__author-name">Tamyla</div>
                        <div class="blog-post__author-title">Founder, Clodo Framework</div>
                    </div>
                </div>
            </header>

            <section class="blog-post__content">
                <h2>The Mystery: Code Pushed, Production Unchanged</h2>
                <p>Picture this: You push a commit to GitHub. The push succeeds. You refresh your production site. Nothing changed.</p>

                <p>You check again. Still old code. You clear your browser cache. Still old code. You wait 10 minutes. <strong>Still old code.</strong></p>

                <p>This is every developer's nightmare‚Äîthe silent failure. No error message, no warning, just... nothing happens.</p>

                <blockquote>
                    <p>"The worst bugs are the ones that don't tell you they're bugs."</p>
                </blockquote>

                <h2>The Investigation Begins</h2>
                
                <h3>Step 1: Verify Git History</h3>
                <pre><code class="language-bash">$ git log --oneline -5
e92cb6f (HEAD -> master, origin/master) Fix production build
c2bad2d Revert unnecessary wrangler.toml build command
9049c68 Add pages_build_command to ensure build runs
2518aeb Remove all demo references
97a6119 Add type=button to prevent form submission</code></pre>

                <p>‚úÖ Commits are there. Code is pushed. <code>origin/master</code> matches local.</p>

                <h3>Step 2: Check Cloudflare Pages Dashboard</h3>
                <p>Cloudflare Pages showed "Deployment successful" but the build output was using old code. The timestamp was recent, but the content was stale.</p>

                <p>ü§î Something was wrong with the <strong>source</strong> being built, not the build process itself.</p>

                <h3>Step 3: Inspect Git Status</h3>
                <pre><code class="language-bash">$ git status
On branch master
Your branch is up to date with 'origin/master'.

nothing to commit, working tree clean</code></pre>

                <p>Clean working tree. No uncommitted changes. Everything looks normal.</p>

                <h3>Step 4: The Smoking Gun</h3>
                <pre><code class="language-bash">$ git ls-tree HEAD | grep clodo-starter-template
160000 commit 1c53a56d... clodo-starter-template</code></pre>

                <p>üö® <strong>There it is.</strong> Mode <code>160000</code> means git is tracking <code>clodo-starter-template</code> as a submodule commit reference, not as actual directory contents.</p>

                <h2>Understanding Git Submodules</h2>
                
                <h3>What Are Git Submodules?</h3>
                <p>Git submodules allow you to include one git repository inside another. They're commonly used for:</p>
                <ul>
                    <li>Embedding third-party libraries</li>
                    <li>Sharing code between projects</li>
                    <li>Managing mono-repos</li>
                </ul>

                <h3>How They Work (When They Work)</h3>
                <pre><code class="language-bash"># Properly configured submodule
$ cat .gitmodules
[submodule "clodo-starter-template"]
    path = clodo-starter-template
    url = https://github.com/tamylaa/clodo-starter-template.git

# Git tracks a specific commit
$ git submodule status
1c53a56d... clodo-starter-template (heads/master)</code></pre>

                <p>When properly configured:</p>
                <ol>
                    <li>Parent repo references a specific commit in the submodule</li>
                    <li><code>.gitmodules</code> file defines the submodule location</li>
                    <li><code>git submodule init</code> and <code>git submodule update</code> fetch the code</li>
                </ol>

                <h3>Our Problem: The Half-Configured Submodule</h3>
                <p>Our situation was worse‚Äîwe had a submodule <strong>reference</strong> without the <strong>configuration</strong>:</p>

                <pre><code class="language-bash">$ cat .gitmodules
cat: .gitmodules: No such file or directory

$ git ls-tree HEAD clodo-starter-template
160000 commit 1c53a56d... clodo-starter-template

$ ls -la | grep clodo-starter-template
drwxr-xr-x  clodo-starter-template/</code></pre>

                <p>This created a nightmare scenario:</p>
                <ul>
                    <li>‚úÖ Locally: Directory exists with full contents</li>
                    <li>‚ùå In git: Only a commit reference is tracked</li>
                    <li>‚ùå On Cloudflare Pages: Build fails to fetch submodule (no .gitmodules)</li>
                    <li>‚ùå Build logs: No clear error message</li>
                </ul>

                <h2>How Did This Happen?</h2>
                
                <p>The most common causes:</p>

                <h3>Scenario 1: Accidental git add</h3>
                <pre><code class="language-bash"># You accidentally add a directory that's already a git repo
$ cd project
$ git clone https://github.com/example/library.git
$ git add library/  # ‚ö†Ô∏è git sees .git folder, treats as submodule
$ git commit -m "Add library"</code></pre>

                <h3>Scenario 2: Manual .gitmodules Deletion</h3>
                <pre><code class="language-bash"># Someone removes .gitmodules but not the submodule reference
$ rm .gitmodules
$ git add .gitmodules
$ git commit -m "Remove submodules"
# ‚ö†Ô∏è Submodule reference still exists in git index!</code></pre>

                <h3>Scenario 3: Incomplete Submodule Removal</h3>
                <pre><code class="language-bash"># Wrong way to remove submodule
$ rm -rf clodo-starter-template/
$ git add .
$ git commit
# ‚ö†Ô∏è Reference remains, directory is gone</code></pre>

                <h2>The Fix: Complete Submodule Removal</h2>

                <h3>Step 1: Remove from Git Index</h3>
                <pre><code class="language-bash">$ git rm --cached clodo-starter-template
rm 'clodo-starter-template'</code></pre>

                <p>The <code>--cached</code> flag removes from git tracking but keeps local files intact.</p>

                <h3>Step 2: Prevent Future Issues</h3>
                <pre><code class="language-bash">$ echo "clodo-starter-template/" >> .gitignore
$ git add .gitignore</code></pre>

                <p>Now git will ignore the directory completely.</p>

                <h3>Step 3: Commit and Push</h3>
                <pre><code class="language-bash">$ git commit -m "Fix: remove broken submodule reference"
[master e92cb6f] Fix: remove broken submodule reference
 1 file changed, 1 insertion(+)
 1 file changed, 0 insertions(+), 0 deletions(-)
 delete mode 160000 clodo-starter-template

$ git push origin master</code></pre>

                <h3>Step 4: Verify the Fix</h3>
                <pre><code class="language-bash">$ git ls-tree HEAD | grep clodo-starter-template
# (no output - submodule reference removed!)

$ git status
On branch master
nothing to commit, working tree clean</code></pre>

                <p>‚úÖ Submodule reference gone. Directory now properly ignored.</p>

                <h2>Why Cloudflare Pages Failed Silently</h2>

                <p>Cloudflare Pages build process:</p>
                <ol>
                    <li><strong>Clone repository</strong> - Gets commit references including submodule pointer</li>
                    <li><strong>Check for .gitmodules</strong> - Not found!</li>
                    <li><strong>Skip submodule init</strong> - Can't fetch without configuration</li>
                    <li><strong>Continue build</strong> - Directory doesn't exist, but build doesn't fail immediately</li>
                    <li><strong>Use cached build</strong> - Falls back to last successful build</li>
                </ol>

                <p>The result: New commits are "deployed" but old code is served.</p>

                <h3>Why No Error Message?</h3>
                <p>The build system didn't consider missing submodule initialization a <strong>build failure</strong>‚Äîjust a skipped step. The actual build command (<code>npm run build</code>) succeeded because it didn't reference the missing directory.</p>

                <h2>Lessons Learned: Git Submodule Best Practices</h2>

                <h3>1. Avoid Submodules When Possible</h3>
                <p>Submodules add complexity. Consider alternatives:</p>
                <ul>
                    <li><strong>npm/yarn packages</strong> for JavaScript dependencies</li>
                    <li><strong>Separate repositories</strong> with CI/CD integration</li>
                    <li><strong>Mono-repos</strong> with tools like Nx or Turborepo</li>
                    <li><strong>Git subtrees</strong> if you need embedded repos</li>
                </ul>

                <h3>2. If You Must Use Submodules...</h3>
                <p>Proper initialization:</p>
                <pre><code class="language-bash"># Add submodule correctly
$ git submodule add https://github.com/user/repo.git path/to/submodule

# Always commit .gitmodules
$ git add .gitmodules path/to/submodule
$ git commit -m "Add submodule: repo"

# Clone repository with submodules
$ git clone --recursive https://github.com/user/parent-repo.git

# Update submodules in existing clone
$ git submodule init
$ git submodule update</code></pre>

                <h3>3. Remove Submodules Completely</h3>
                <p>The correct removal process:</p>
                <pre><code class="language-bash"># 1. Remove submodule entry from .gitmodules
$ git config -f .gitmodules --remove-section submodule.path/to/submodule

# 2. Remove submodule entry from .git/config
$ git config -f .git/config --remove-section submodule.path/to/submodule

# 3. Remove from index
$ git rm --cached path/to/submodule

# 4. Remove .git metadata
$ rm -rf .git/modules/path/to/submodule

# 5. Remove files
$ rm -rf path/to/submodule

# 6. Commit
$ git commit -m "Remove submodule: path/to/submodule"</code></pre>

                <h3>4. Configure Build Systems for Submodules</h3>
                <p>Most CI/CD platforms need explicit configuration:</p>

                <p><strong>GitHub Actions:</strong></p>
                <pre><code class="language-yaml">- name: Checkout code
  uses: actions/checkout@v3
  with:
    submodules: recursive  # ‚Üê Important!</code></pre>

                <p><strong>Cloudflare Pages:</strong></p>
                <pre><code class="language-toml"># wrangler.toml
[build]
command = "git submodule update --init --recursive && npm run build"</code></pre>

                <p><strong>Vercel:</strong> Auto-detects and initializes submodules by default.</p>

                <h2>Alternative: Our Chosen Solution</h2>
                
                <p>Instead of fighting with submodules, we chose a cleaner approach:</p>

                <h3>Separate Repositories</h3>
                <ul>
                    <li><strong>clodo-dev-site</strong> - Marketing website</li>
                    <li><strong>clodo-starter-template</strong> - StackBlitz demo (separate repo)</li>
                    <li><strong>clodo-framework</strong> - Framework npm package</li>
                </ul>

                <h3>Benefits</h3>
                <ol>
                    <li><strong>Independent versioning</strong> - Update demo without touching website</li>
                    <li><strong>No build dependencies</strong> - Each deploys independently</li>
                    <li><strong>Clear separation</strong> - Demo code isn't mixed with marketing site</li>
                    <li><strong>GitHub template</strong> - Can mark demo as template for easy forking</li>
                    <li><strong>StackBlitz integration</strong> - Direct URL to separate repo</li>
                </ol>

                <h3>Trade-offs</h3>
                <ul>
                    <li>‚ùå Manual sync if demo needs website changes</li>
                    <li>‚ùå Can't test demo changes locally within website repo</li>
                    <li>‚úÖ But: Demo is deployed to StackBlitz, not our site</li>
                    <li>‚úÖ Simpler mental model and deployment</li>
                </ul>

                <h2>Debugging Checklist for Silent Build Failures</h2>

                <p>When production doesn't update after pushing code:</p>

                <h3>1. Verify Git State</h3>
                <pre><code class="language-bash"># Check commit history
$ git log --oneline -10

# Verify remote sync
$ git fetch
$ git status

# Check for uncommitted changes
$ git diff
$ git diff --staged</code></pre>

                <h3>2. Check for Submodule Issues</h3>
                <pre><code class="language-bash"># List submodule references
$ git ls-tree HEAD | grep "^160000"

# Check .gitmodules
$ cat .gitmodules

# Submodule status
$ git submodule status</code></pre>

                <h3>3. Inspect Build Logs</h3>
                <ul>
                    <li>Cloudflare Pages: Dashboard ‚Üí Deployments ‚Üí View build log</li>
                    <li>Vercel: Deployment ‚Üí View function logs</li>
                    <li>Netlify: Deploys ‚Üí Deploy log</li>
                </ul>

                <h3>4. Test Build Locally</h3>
                <pre><code class="language-bash"># Run production build locally
$ npm run build

# Simulate fresh clone
$ cd /tmp
$ git clone https://github.com/user/repo.git
$ cd repo
$ npm install
$ npm run build</code></pre>

                <h3>5. Check Cache</h3>
                <p>Many platforms cache builds. Try:</p>
                <ul>
                    <li>Force rebuild (Cloudflare: "Retry deployment")</li>
                    <li>Clear cache (Vercel: "Clear cache and redeploy")</li>
                    <li>Push empty commit to trigger rebuild</li>
                </ul>

                <h2>Tools for Detection</h2>

                <h3>Git Hooks</h3>
                <p>Prevent accidental submodule commits:</p>
                <pre><code class="language-bash">#!/bin/bash
# .git/hooks/pre-commit

# Check for accidental submodule additions
SUBMODULES=$(git diff --cached --name-only --diff-filter=A | \
    while read file; do
        if [ -d "$file" ] && [ -d "$file/.git" ]; then
            echo "$file"
        fi
    done)

if [ -n "$SUBMODULES" ]; then
    echo "Error: Attempting to add directories with .git folders:"
    echo "$SUBMODULES"
    echo "Did you mean to add these as submodules?"
    exit 1
fi</code></pre>

                <h3>CI/CD Validation</h3>
                <p>Check for submodule misconfigurations:</p>
                <pre><code class="language-yaml"># .github/workflows/validate.yml
name: Validate Repository
on: [push, pull_request]

jobs:
  check-submodules:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Check for broken submodules
        run: |
          # Find submodule references
          REFS=$(git ls-tree HEAD | grep "^160000" | cut -f2)
          
          if [ -n "$REFS" ]; then
            echo "Found submodule references:"
            echo "$REFS"
            
            # Verify .gitmodules exists
            if [ ! -f .gitmodules ]; then
              echo "Error: Submodules found but .gitmodules missing!"
              exit 1
            fi
          fi</code></pre>

                <h2>Conclusion</h2>

                <p>Silent failures are the worst kind of bugs. They don't crash, they don't error‚Äîthey just quietly break your deployment pipeline.</p>

                <p>The broken git submodule issue taught us:</p>
                <ol>
                    <li><strong>Verify the source</strong> - Don't assume pushed code is deployed code</li>
                    <li><strong>Submodules need full configuration</strong> - Or avoid them entirely</li>
                    <li><strong>Test fresh clones</strong> - Your local environment lies</li>
                    <li><strong>Check build logs</strong> - Even "successful" builds can hide issues</li>
                    <li><strong>Simplify when possible</strong> - Separate repos beat complex submodule hierarchies</li>
                </ol>

                <p>By removing the broken submodule and moving to separate repositories, we eliminated an entire class of deployment issues. Sometimes the best debugging is prevention.</p>

                <h2>Related Reading</h2>
                <ul>
                    <li><a href="/blog/stackblitz-integration-journey.html">Building an Instant "Try Now" Experience</a> - The full integration story</li>
                    <li><a href="https://git-scm.com/book/en/v2/Git-Tools-Submodules">Git Submodules Official Documentation</a></li>
                    <li><a href="https://developers.cloudflare.com/pages/configuration/build-configuration/">Cloudflare Pages Build Configuration</a></li>
                </ul>
            </section>

            <footer class="blog-post__footer">
                <div class="blog-post__tags">
                    <a href="/blog?tag=debugging" class="tag">Debugging</a>
                    <a href="/blog?tag=git" class="tag">Git</a>
                    <a href="/blog?tag=deployment" class="tag">Deployment</a>
                    <a href="/blog?tag=cloudflare" class="tag">Cloudflare Pages</a>
                </div>

                <div class="blog-post__cta">
                    <h3>Building on Cloudflare Workers?</h3>
                    <p>Clodo Framework handles deployment complexity for you.</p>
                    <a href="/docs.html" class="btn btn-primary">Get Started</a>
                </div>
            </footer>
        </article>
    </main>

    <!--#include file="../../templates/footer.html" -->
    <script src="../script.js" nonce="N0Nc3Cl0d0"></script>
</body>
</html>